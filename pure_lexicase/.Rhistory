d[i, 2] = (((second + 1) * (first + 1)) / (both + 1)) - 1
}
d
ggplot(d, aes(y=c(a,b))) + geom_boxplot()
library(ggplot2)
ggplot(d, aes(y=c(a,b))) + geom_boxplot()
ggplot(d, aes(x=a, y=b) + geom_point()
ggplot(d, aes(x=a, y=b)) + geom_point()
library(ggplot2)
ggplot(d, aes(x=a, y=b)) + geom_point()
library(ggplot2)
ggplot(d) + geom_histogram(aes(y = a)) + geom_histogram(aes(y = b))
library(ggplot2)
ggplot(d) + geom_histogram(y = a) + geom_histogram(y = b)
ggplot(d) + geom_histogram(d, y = a)
ggplot(d) + geom_histogram(d, aes(y = a))
rbinom(1, 1, prob = 0.5)
rbinom(1, 1, prob = 0.5)
rbinom(1, 1, prob = 0.5)
rbinom(1, 1, prob = 0.5)
rbinom(1, 1, prob = 0.5)
if(rbinom(1, 1, prob = 0.5))
print('Ben'))
if(rbinom(1, 1, prob = 0.5)){
print('Ben')
}else{
print('Skye')
}
if(rbinom(1, 1, prob = 0.5)){
print('Ben')
}else{
print('Skye')
}
if(rbinom(1, 1, prob = 0.5)){
print('Ben')
}else{
print('Skye')
}
if(rbinom(1, 1, prob = 0.5)){
print('Ben')
}else{
print('Skye')
}
rm(list=ls())
num_iters = 1000
d = data.frame(data=matrix(nrow = 2 * num_iters, ncol = 2))
colnames(d) = c('a', 'b')
for(i  in 1:num_iters){
n = 60
max_val = 2
A = floor(runif(n, min = 1, max = max_val + 1))
B = floor(runif(n, min = 1, max = max_val + 1))
M = matrix(nrow = n, ncol = 2, data = c(A,B), byrow = T)
first_check = 1
second_check = 2
first = nrow(M[M[,1] == first_check,])
second = nrow(M[M[,2] == second_check,])
both = nrow(M[M[,1] == first_check & M[,2] == second_check,])
d[i * 2 - 1, 1] = 1
d[i * 2 - 1, 1] = first * second / both
d[i * 2, 1] = 2
d[i * 2, 2] = (((second + 1) * (first + 1)) / (both + 1)) - 1
}
library(ggplot2)
rm(list=ls())
num_iters = 1000
d = data.frame(data=matrix(nrow = 2 * num_iters, ncol = 3))
colnames(d) = c('a', 'b')
for(i  in 1:num_iters){
n = 60
max_val = 2
A = floor(runif(n, min = 1, max = max_val + 1))
B = floor(runif(n, min = 1, max = max_val + 1))
M = matrix(nrow = n, ncol = 2, data = c(A,B), byrow = T)
first_check = 1
second_check = 2
first = nrow(M[M[,1] == first_check,])
second = nrow(M[M[,2] == second_check,])
both = nrow(M[M[,1] == first_check & M[,2] == second_check,])
d[i * 2 - 1, 1] = 1
d[i * 2 - 1, 1] = first * second / both
d[i * 2, 1] = 2
d[i * 2, 2] = (((second + 1) * (first + 1)) / (both + 1)) - 1
}
rm(list=ls())
num_iters = 1000
d = data.frame(data=matrix(nrow = 2 * num_iters, ncol = 3))
colnames(d) = c('a', 'b')
for(i  in 1:num_iters){
n = 60
max_val = 2
A = floor(runif(n, min = 1, max = max_val + 1))
B = floor(runif(n, min = 1, max = max_val + 1))
M = matrix(nrow = n, ncol = 2, data = c(A,B), byrow = T)
first_check = 1
second_check = 2
first = nrow(M[M[,1] == first_check,])
second = nrow(M[M[,2] == second_check,])
both = nrow(M[M[,1] == first_check & M[,2] == second_check,])
d[i * 3 - 2, 1] = floor((i+1) / 2)
d[i * 3 - 1, 2] = 1
d[i * 3 - 1, 3] = first * second / both
d[i * 3 - 2, 1] = floor((i+1) / 2)
d[i * 3 - 1, 2] = 2
d[i * 3, 3] = (((second + 1) * (first + 1)) / (both + 1)) - 1
}
d
d[i * 2 - 1, 1] = floor((i+1) / 2)
d[i * 2 - 1, 2] = 1
d[i * 2 - 1, 3] = first * second / both
d[i * 2, 1] = floor((i+1) / 2)
d[i * 2, 2] = 2
d[i * 2, 3] = (((second + 1) * (first + 1)) / (both + 1)) - 1
rm(list=ls())
num_iters = 1000
d = data.frame(data=matrix(nrow = 2 * num_iters, ncol = 3))
colnames(d) = c('a', 'b')
for(i  in 1:num_iters){
n = 60
max_val = 2
A = floor(runif(n, min = 1, max = max_val + 1))
B = floor(runif(n, min = 1, max = max_val + 1))
M = matrix(nrow = n, ncol = 2, data = c(A,B), byrow = T)
first_check = 1
second_check = 2
first = nrow(M[M[,1] == first_check,])
second = nrow(M[M[,2] == second_check,])
both = nrow(M[M[,1] == first_check & M[,2] == second_check,])
d[i * 2 - 1, 1] = floor((i+1) / 2)
d[i * 2 - 1, 2] = 1
d[i * 2 - 1, 3] = first * second / both
d[i * 2, 1] = floor((i+1) / 2)
d[i * 2, 2] = 2
d[i * 2, 3] = (((second + 1) * (first + 1)) / (both + 1)) - 1
}
library(ggplot2)
ggplot(d, aes(x = )) + geom_histogram(d, aes(y = a))
if(rbinom(1, 1, prob = 0.5)){
print('Ben')
}else{
print('Skye')
}
a=d
d
library(ggplot2)
library(ggplot2)
ggplot(d, aes(x = trt, y = guess)) + geom_histogram()
rm(list=ls())
num_iters = 1000
d = data.frame(data=matrix(nrow = 2 * num_iters, ncol = 3))
colnames(d) = c('round', 'trt', 'guess')
for(i  in 1:num_iters){
n = 60
max_val = 2
A = floor(runif(n, min = 1, max = max_val + 1))
B = floor(runif(n, min = 1, max = max_val + 1))
M = matrix(nrow = n, ncol = 2, data = c(A,B), byrow = T)
first_check = 1
second_check = 2
first = nrow(M[M[,1] == first_check,])
second = nrow(M[M[,2] == second_check,])
both = nrow(M[M[,1] == first_check & M[,2] == second_check,])
d[i * 2 - 1, 1] = floor((i+1) / 2)
d[i * 2 - 1, 2] = 1
d[i * 2 - 1, 3] = first * second / both
d[i * 2, 1] = floor((i+1) / 2)
d[i * 2, 2] = 2
d[i * 2, 3] = (((second + 1) * (first + 1)) / (both + 1)) - 1
}
library(ggplot2)
ggplot(d, aes(x = trt, y = guess)) + geom_histogram()
if(rbinom(1, 1, prob = 0.5)){
print('Ben')
}else{
print('Skye')
}
d
rm(list=ls())
num_iters = 1000
d = data.frame(data=matrix(nrow = 2 * num_iters, ncol = 3))
colnames(d) = c('round', 'trt', 'guess')
for(i  in 1:num_iters){
n = 60
max_val = 2
A = floor(runif(n, min = 1, max = max_val + 1))
B = floor(runif(n, min = 1, max = max_val + 1))
M = matrix(nrow = n, ncol = 2, data = c(A,B), byrow = T)
first_check = 1
second_check = 2
first = nrow(M[M[,1] == first_check,])
second = nrow(M[M[,2] == second_check,])
both = nrow(M[M[,1] == first_check & M[,2] == second_check,])
d[i * 2 - 1, 1] = floor((i+1) / 2)
d[i * 2 - 1, 2] = 1
d[i * 2 - 1, 3] = first * second / both
d[i * 2, 1] = floor((i+1) / 2)
d[i * 2, 2] = 2
d[i * 2, 3] = (((second + 1) * (first + 1)) / (both + 1)) - 1
}
library(ggplot2)
ggplot(d, aes(x = trt, y = guess)) + geom_histogram()
ggplot(d, aes(x = trt, y = guess))
ggplot(d, aes(x = trt, y = guess)) + geom_histogram()
ggplot(d, aes(x = trt, y = guess)) + geom_boxplot()
# Austin Ferguson
# In Class Notes
# 2/12/2019
# Gamma Distribution
# Most often a helper distribution
# Negative Binomial Distribution
# Two parameters:
# p - Success Probability
# r - Size
# Like a poisson distribution, but the variance is a random variable coming from a gamma distribution
# Link Function : Log
# Useful for counts that can vary wildly
# Think observing bird counts for 10 minutes, often a handful but possibly hundreds
# Beta Distributions
# Dependent data are proportions
rm(list=ls())
num_iters = 1000
d = data.frame(data=matrix(nrow = 2 * num_iters, ncol = 3))
colnames(d) = c('round', 'trt', 'guess')
for(i  in 1:num_iters){
n = 60
max_val = 2
A = floor(runif(n, min = 1, max = max_val + 1))
B = floor(runif(n, min = 1, max = max_val + 1))
M = matrix(nrow = n, ncol = 2, data = c(A,B), byrow = T)
first_check = 1
second_check = 2
first = nrow(M[M[,1] == first_check,])
second = nrow(M[M[,2] == second_check,])
both = nrow(M[M[,1] == first_check & M[,2] == second_check,])
d[i * 2 - 1, 1] = floor((i+1) / 2)
d[i * 2 - 1, 2] = 1
d[i * 2 - 1, 3] = first * second / both
d[i * 2, 1] = floor((i+1) / 2)
d[i * 2, 2] = 2
d[i * 2, 3] = (((second + 1) * (first + 1)) / (both + 1)) - 1
}
d$trt = as.factor(d$trt)
library(ggplot2)
ggplot(d, aes(x = trt, y = guess)) + geom_boxplot()
ggplot(d, aes(x = trt, y = guess)) + geom_boxplot() + geom_abline(y=60)
ggplot(d, aes(x = trt, y = guess)) + geom_boxplot() + geom_abline(aes(y=60))
ggplot(d, aes(x = trt, y = guess)) + geom_boxplot() + geom_hline(yintercept = n)
# Austin Ferguson
# In Class Notes
# 2/12/2019
# Gamma Distribution
# Most often a helper distribution
# Negative Binomial Distribution
# Two parameters:
# p - Success Probability
# r - Size
# Like a poisson distribution, but the variance is a random variable coming from a gamma distribution
# Link Function : Log
# Useful for counts that can vary wildly
# Think observing bird counts for 10 minutes, often a handful but possibly hundreds
# Beta Distributions
# Dependent data are proportions
rm(list=ls())
num_iters = 1000
d = data.frame(data=matrix(nrow = 2 * num_iters, ncol = 3))
colnames(d) = c('round', 'trt', 'guess')
for(i  in 1:num_iters){
n = 60
max_val = 2
A = floor(runif(n, min = 1, max = max_val + 1))
B = floor(runif(n, min = 1, max = max_val + 1))
M = matrix(nrow = n, ncol = 2, data = c(A,B), byrow = T)
first_check = 1
second_check = 2
first = nrow(M[M[,1] == first_check,])
second = nrow(M[M[,2] == second_check,])
both = nrow(M[M[,1] == first_check & M[,2] == second_check,])
d[i * 2 - 1, 1] = floor((i+1) / 2)
d[i * 2 - 1, 2] = 1
d[i * 2 - 1, 3] = first * second / both
d[i * 2, 1] = floor((i+1) / 2)
d[i * 2, 2] = 2
d[i * 2, 3] = (((second + 1) * (first + 1)) / (both + 1)) - 1
}
library(ggplot2)
ggplot(d, aes(x = trt, y = guess)) + geom_boxplot() + geom_hline(yintercept = n)
max_val = 2
A = floor(runif(n, min = 1, max = max_val + 1))
B = floor(runif(n, min = 1, max = max_val + 1))
# Austin Ferguson
# In Class Notes
# 2/12/2019
# Gamma Distribution
# Most often a helper distribution
# Negative Binomial Distribution
# Two parameters:
# p - Success Probability
# r - Size
# Like a poisson distribution, but the variance is a random variable coming from a gamma distribution
# Link Function : Log
# Useful for counts that can vary wildly
# Think observing bird counts for 10 minutes, often a handful but possibly hundreds
# Beta Distributions
# Dependent data are proportions
rm(list=ls())
num_iters = 1000
d = data.frame(data=matrix(nrow = 2 * num_iters, ncol = 3))
colnames(d) = c('round', 'trt', 'guess')
for(i  in 1:num_iters){
n = 60
max_val = 2
A = floor(runif(n, min = 1, max = max_val + 1))
B = floor(runif(n, min = 1, max = max_val + 1))
M = matrix(nrow = n, ncol = 2, data = c(A,B), byrow = T)
first_check = 1
second_check = 2
first = nrow(M[M[,1] == first_check,])
second = nrow(M[M[,2] == second_check,])
both = nrow(M[M[,1] == first_check & M[,2] == second_check,])
d[i * 2 - 1, 1] = floor((i+1) / 2)
d[i * 2 - 1, 2] = 1
d[i * 2 - 1, 3] = first * second / both
d[i * 2, 1] = floor((i+1) / 2)
d[i * 2, 2] = 2
d[i * 2, 3] = (((second + 1) * (first + 1)) / (both + 1)) - 1
}
library(ggplot2)
ggplot(d, aes(x = trt, y = guess)) + geom_boxplot() + geom_hline(yintercept = n)
library(ggplot2)
ggplot(d, aes(x = trt, y = guess)) + geom_boxplot() + geom_hline(yintercept = n)
ggplot(d, aes(x = trt, y = guess, group=trt)) + geom_boxplot() + geom_hline(yintercept = n)
ggplot(d, aes(x = trt, y = guess, group=trt)) + geom_violin() + geom_boxplot() + geom_hline(yintercept = n)
ggplot(d, aes(x = trt, y = guess, group=trt)) + geom_violin() + geom_hline(yintercept = n)
ggplot(d, aes(x = trt, y = guess, group=trt, color=trt)) + geom_violin() + geom_hline(yintercept = n)
ggplot(d, aes(x = trt, y = guess, group=trt, fill=trt)) + geom_violin() + geom_hline(yintercept = n)
ggplot(d, aes(x = trt, y = guess, group=trt, fill=as.factor(trt)) + geom_violin() + geom_hline(yintercept = n)
ggplot(d, aes(x = trt, y = guess, group=trt, fill=as.factor(trt))) + geom_violin() + geom_hline(yintercept = n)
ggplot(d, aes(x = trt, y = guess, group=trt, fill=as.factor(trt))) + geom_violin() + geom_hline(yintercept = n)
ggplot(d, aes(x = trt, y = guess, group=trt, fill=as.factor(trt))) + geom_violin() + geom_jitter() + geom_hline(yintercept = n)
ggplot(d, aes(x = trt, y = guess, group=trt, fill=as.factor(trt))) + geom_violin() + geom_point() + geom_hline(yintercept = n)
packages.install(RTTS)
packages.install(Rtts)
install.packages("Rtts")
install.packages("RCurl")
install.packages("Rtts")
install.packages("RCurl")
install.packages('RCapture')
install.packages('Rcapture')
library(Rcapture)
duck
ducks
??Rcapture
install.packages('RMark')
library(RMark)
install.packages('mvtnorm')
install.packages('mvtnorm', dependencies=TRUE, repos='http://cran.rstudio.com/')
clear
M = 15
C = 14
R = 4
print(M * C / R)
M = 16
C = 14
R = 4
print(M * C / R)
M = 15
C = 14
R = 4
print(M * C / R)
# Load packages
library(ggplot2) # for plotting
library(GGally) # for ggpairs function, pairwise plotting of multiple variables
library(lme4) # for GLMMs
library(piecewiseSEM) # for the nice rsquared() function
# Install packages if you don't have them:
# install.packages('ggplot2')
# install.packages('GGally')
# install.packages('lme4')
install.packages('piecewiseSEM')
library(piecewiseSEM) # for the nice rsquared() function
# Tell R not use print numbers with scientific notation
# Makes them easier to understand quickly, I think
options(scipen=10)
# Install packages if you don't have them:
# install.packages('ggplot2')
# install.packages('GGally')
# install.packages('lme4')
install.packages('piecewiseSEM')
# Install packages if you don't have them:
# install.packages('ggplot2')
# install.packages('GGally')
# install.packages('lme4')
install.packages('piecewiseSEM')
# Load packages
library(ggplot2) # for plotting
# Load packages
library(ggplot2) # for plotting
# Install packages if you don't have them:
install.packages('ggplot2')
update.packages(ask = FALSE)
# Load packages
library(ggplot2) # for plotting
# There's not much here, just looking at which replicates found solutions
rm(list=ls())
library(ggplot2)
library(GGally)
library(tidyr)
library(plyr)
library(dplyr)
setwd('~/Research/lexicase/gptp-2019-cohort-lexicase/data/out')
## ORGINIAL RUNS
data = read.csv('replicate_data.csv', stringsAsFactors = FALSE)
problems = unique(data$problem)
treatments = unique(data$treatment)
sizes = unique(data$num_tests)
dilutions = unique(data$dilution)
data$found = data$solution_found == 'True'
res = matrix(ncol=5, nrow=0)
for(prob in problems){
for(trt in treatments){
for(size in sizes){
for(dil in dilutions){
tmp = data[data$problem == prob & data$treatment == trt & data$num_tests == size & data$dilution == dil & data$found,]
res = rbind(res, c(prob, trt, size, dil, nrow(tmp)))
print(tmp[tmp$found,])
}
}
}
}
res_df = data.frame(data=res)
colnames(res_df) = c('problem', 'treatment', 'num_tests', 'dilution', 'solutions_found')
res_df$solutions_found = as.numeric(as.character(res_df$solutions_found))
res_df$num_tests = ordered(res_df$num_tests, c('5', '10', '25', '50', '100'))
res_df$size = as.numeric(as.character(res_df$num_tests))
ggplot(data = res_df[res_df$problem == 'smallest',], mapping=aes(x=treatment, y=solutions_found, fill=treatment)) +
geom_bar(stat="identity") +
guides(fill=FALSE) +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) + ylim(0, 55) +
geom_text(aes(label=solutions_found), nudge_y=3) +
facet_grid(dilution ~ num_tests ) + ggtitle('"Smallest" - Solutions Found')
##########################################################################
###############    Checking for overfit solutions    #####################
##########################################################################
data$found_train = data$solution_found == 'True' | (data$max_actual_score == data$num_tests)
res_train = matrix(ncol=5, nrow=0)
for(prob in problems){
for(trt in treatments){
for(size in sizes){
for(dil in dilutions){
tmp = data[data$problem == prob & data$treatment == trt & data$num_tests == size & data$dilution == dil & data$found_train,]
res_train = rbind(res_train, c(prob, trt, size, dil, nrow(tmp)))
print(tmp[tmp$found,])
}
}
}
}
res_train_df = data.frame(data=res_train)
colnames(res_train_df) = c('problem', 'treatment', 'num_tests', 'dilution', 'train_solutions')
res_train_df$train_solutions = as.numeric(as.character(res_train_df$train_solutions))
res_train_df$num_tests = ordered(res_train_df$num_tests, c('5', '10', '25', '50', '100'))
res_train_df$size = as.numeric(as.character(res_train_df$num_tests))
ggplot(data = res_train_df[res_train_df$problem == 'smallest',], mapping=aes(x=treatment, y=train_solutions, fill=treatment)) +
geom_bar(stat="identity") +
guides(fill=FALSE) +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) + ylim(0, 55) +
geom_text(aes(label=train_solutions), nudge_y=3) +
facet_grid(dilution ~ num_tests ) + ggtitle('"Smallest" - Number of solutions to entire *training* set')
all_res_df = full_join(res_df, res_train_df, by=c('problem', 'treatment', 'num_tests', 'dilution', 'size'))
ggplot(data = all_res_df[all_res_df$problem == 'smallest',], mapping=aes(x=treatment, y=train_solutions - solutions_found, fill=treatment)) +
geom_bar(stat="identity") +
guides(fill=FALSE) +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) + ylim(0, 55) +
geom_text(aes(label=train_solutions - solutions_found), nudge_y=3) +
facet_grid(dilution ~ num_tests ) + ggtitle('"Smallest" - Number of solutions for training but not test')
setwd('~/Research/lexicase/gptp-2019-subsampling-lexicase/data/out')
setwd('~/Research/lexicase/gptp-2019-cohort-lexicase/data/out')
setwd('~/Research/lexicase/gptp-2019-cohort-lexicase/data/out/pure_lexicase')
data = read.csv('solved/gen_0.csv')
data
data = read.csv('solved/gen_133.csv')
data
data["c1" == 1, ]
data["c1" == '1', ]
data[data$c0 == 1, ]
rowSums(data[,2:ncol(data)])
data = read.csv('solved/gen_100.csv')
rowSums(data[,2:ncol(data)])
data = read.csv('solved/gen_133.csv')
rowSums(data[,2:ncol(data)])
data
data[rowSums(data[,2:ncol(data)]) = 100,]
data$sum = rowSums(data[,2:ncol(data)])
data
data$sum
data[data$sum == 100, ]
ncol(data[data$sum == 100, ])
nrow(data[data$sum == 100, ])
setwd('~/Research/lexicase/gptp-2019-cohort-lexicase/data/out/pure_lexicase')
data = read.csv('overfit/gen_300.csv')
data$sum = rowSums(data[,2:ncol(data)])
nrow(data[data$sum == 100, ])
clear
data
data = read.csv('solved/gen_133.csv')
data$sum = rowSums(data[,2:ncol(data)])
data
data[data$prog_id == 161,]
data[data$prog_id == 161,]
setwd('~/Research/lexicase/gptp-2019-cohort-lexicase/data/out/pure_lexicase')
data = read.csv('solved/gen_133.csv')
data$sum = rowSums(data[,2:ncol(data)])
data[data$prog_id == 161,]
